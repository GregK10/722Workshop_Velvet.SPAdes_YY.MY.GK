# Introduction to Velvet

Velvet is a _de novo_ assembler designed for short reads, and also works for very short reads (25 - 50 bp). Velvet removes errors present within these reads and then assembles them into contigs. 

#### Imput files can be
- Fasta
- Fastq
- sam 
- bam 
 
### Velvet works with short sequences data
 
Velvet is useful as it can produce long contigs in excess of 150kb from paired end short reads
 
## Velvet Workshop (Velvet 1.2.10)

Similar to SPAdes, the code to run Velvet is straightforward

#### Here we are using two main velvet funtions ```velveth```and ```velvetg```

- ```velveth``` reads the sequence files and builds a dictionary of all words of length k. It constructs the k-mers using the reads in preparation for assembly (i.e. input into velvetg)
- ```velvetg``` reads these alignments produced by ```velveth```, builds a de Bruijn graph from them, removes errors and simplifies the graph and resolve repeats. 

### Step 1 ```velveth```:

The format to run velveth is below
```
velveth [ourput_directory] [hash value] -[read_type] -[file_format] -separate -[file_1] -[file_2]
```
#### Flags for ```velveth```
- ```velvet_31``` is the name for the directory. It will generate and fill the directory with the functions outputs.
- 31 is the hash value we are using in this example. 
- ```-shortpaired``` is the type of reads we are using (short and paired-end reads)
- ```-fastq``` is read type file
- ```-separate```  indicated paired-end reads are in separate files

### Let's run the command using our files
```
velveth velvet_31 31 -shortPaired -fastq -separate B4546_1s.fastq B4546_2s.fastq
```
### Step 2 ```velvetg```:
The format to run velvetg is below
```
velvetg [velveth_input_directory] [Read_coverage]
```

#### Flags for ```velvetg```
- ```velvet_31``` is the name for the directory 
- ```-cov_cutoff auto``` is the coverage cutoff value. We have it set to auto which will set this value to half the length weighted median contig coverage depth. Although you may wish to optimise this parameter in further iterations, auto allows you to quickly obtain a decent assembly in your first run.

### Let's run the command using our the files generated by ```velveth```
```
velvetg velvet_31 -cov_cutoff auto
```

Output
```
 -**contigs.fa** contains Contig sequences in FASTA format
 -**stats.txt** is a tab-separated table with statistics on the contigs
 -**Sequences** contains the sequences we put in
 -**Roadmaps** contains the index you just created
 -**Log** has a useful reminder of what commands you typed to get this assembly result
```

## VelvetOptimiser workshop
You can also optimize your velvet assembly runs using VelvetOptimiser. This module goes through a range of hash values (k-mer value) for the optimum k-mer size, estimates the expected coverage and then searches for the optimum coverage cutoff. It does this by performing many runs of Velvet. 

#### But first we need to merge the two fastq files together as Velvetoptimizer will only takes this single merged file as input
We want each read is paired with the one directly above or the one directly below

To merge the two fastq files together, we will use the ```shufflereads_fastq.pl```, a command that is included with Velvet
######  (```shufflereads_fasta.pl``` if your files are in fasta format)

The format is
```
shuffleReads_fastq.pl [reads_1.fastq] [reads_2.fq] [merged_output.fastq]
```
For our workshop, input in the following script
```
/usr/local/velvet/velvet_1.2.10/contrib/shuffleSequences_fasta/shuffleSequences_fastq.pl B4546_1s.fastq B4546_2s.fastq merged.fastq
```

#### In addition to the VelvetOptimiser script, two flags are necessary. The flags require their parameter string to be encased with either ' ' or " "
- ```-d [directory_name]``` will create a directory for our output files
- ```-f {[-file_format][-read_type] filename}``` is just the input line you would have put into velveth

#### Some details on VelvetOptimiser
- The optimisation function for k-mer choice uses 'n50' by default but this can be changed with the flag ```--optFuncKmer```
- The optimisation for coverage cutoff uses 'the total number of bases in large contigs' by default but can be changed with ```--optFuncCov```
- This time we are just using the default range of hash values (or k-mer), which are set at strating hash value of 19, end hash value of 31, and the steps in the hash search being 2 (this program will use all these values to try and find the most optimal hash size)
 	-  In our workshop, the optimal hash value was determined to be 25
- The flag ```-shortPaired``` represents that illumina paired-end reads are used

### Now to run VelvetOptimiser on the merged file we created, we will use the following script
```
/usr/local/velvet/velvet_1.2.10/contrib/VelvetOptimiser-2.2.4/VelvetOptimiser.pl -d 'velvet' -f '-fastq -shortPaired merged.fastq'
```

### The output directory contains 8 files

29-03-2021-12-37-05_Logfile.txt  
contigs.fa  
Graph  
Graph2  
Log  
PreGraph  
Sequences  
stats.txt

#### Now that we have assembled contigs using both SPAdes and Velvet, let us check out summary statistics using [QUAST](https://github.com/GregK10/722Workshop_Velvet.SPAdes_YY.MY.GK/blob/main/4_QUAST.md). Away we go!!
